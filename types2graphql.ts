// Import typescript to work with AST (Abstract Syntax Tree)
import ts from "typescript";
import * as fs from "fs";
import * as path from "path";
import { IValidSchemaInterface } from "./IValidSchemaInterface";
import { typing } from "./typing-enum";
import {
  findAllInterfaceDeclarationsFromSourceFile,
  getValidSchemaInterfaces,
  selectValidSchemaInterfaces,
} from "./valid-interface-selector";
import { convertInterfaceToGraphQLSchema } from "./schema-generator";
var graphQLSchemasInFolder: string[] = [];

function findAllSchemaInterfacesInSourceFile(
  sourceFile: ts.SourceFile
): ts.InterfaceDeclaration[] {
  // Ensure to filter only interface declarations
  const interfaceDeclarations = sourceFile.statements.filter(
    ts.isInterfaceDeclaration
  );

  // Print the generated Abstract Interface Declaration
  console.log(interfaceDeclarations);
  return interfaceDeclarations;
}

function generateSourceFileFromSourceCode(sourceCode: string): ts.SourceFile {
  const sourceFile = ts.createSourceFile(
    "temp.ts",
    sourceCode,
    ts.ScriptTarget.Latest
  );

  return sourceFile;
}

function parseFileToSourceCode(filePath: string): string {
  // Read TypeScript code from a file
  const fullFilePath = path.join(__dirname, filePath);
  const sourceCode = fs.readFileSync(fullFilePath, "utf-8");

  // Print the parsed source code
  console.log(sourceCode);
  return sourceCode;
}

function readFilesInFolder(folderPath: string): string[] {
  try {
    // Get the list of files in the folder
    const files = fs.readdirSync(folderPath);

    // Filter out only files (not directories)
    const filePaths = files
      .map((file) => path.join(folderPath, file))
      .filter((filePath) => fs.statSync(filePath).isFile());

    return filePaths;
  } catch (error: any) {
    console.error(
      `Error reading files in folder ${folderPath}: ${error.message}`
    );
    return [];
  }
}

function getValidSchemaInterfacesPerSourceFile(sourceFile: ts.SourceFile) {
  const interfacesInSourceFile =
    findAllInterfaceDeclarationsFromSourceFile(sourceFile);
  selectValidSchemaInterfaces(interfacesInSourceFile, sourceFile);
}

function getGraphQLFromSchemaInterfaces() {
  const validSchemaInterfaces = getValidSchemaInterfaces();
  validSchemaInterfaces.forEach((schemaInterface) => {
    const graphQLSchema = convertInterfaceToGraphQLSchema(schemaInterface);
    graphQLSchemasInFolder.push(graphQLSchema);
  });
}

function writeToFile(filePath: string, content: string): void {
  fs.writeFileSync(filePath, content, "utf-8");
}

function createGraphQLFile(appName: string, interfaceFolderPath: string) {
  // todo: use appName to generate the graph file in the folderPath specified
  const graphQLFileName = `${appName}.graphql`;
  const graphQLFilePath = path.join(interfaceFolderPath, graphQLFileName);
  const graphQLFileContent = `
  GraphQL Schema Generated by typesql library from path: ${interfaceFolderPath}

  Modifying this file will not have any effect as it will be regenerated on server startup.

${graphQLSchemasInFolder.join("\n\n")}
  `;
  writeToFile(graphQLFilePath, graphQLFileContent);
}

export function generateGraphQLSchema(
  interfaceFolderPath: string,
  appName: string
) {
  const filePaths = readFilesInFolder(interfaceFolderPath);
  filePaths.forEach((filePath) => {
    const sourceCode = parseFileToSourceCode(filePath);
    const sourceFile = generateSourceFileFromSourceCode(sourceCode);
    getValidSchemaInterfacesPerSourceFile(sourceFile);
    getGraphQLFromSchemaInterfaces();
    createGraphQLFile(appName, interfaceFolderPath);
  });
}
